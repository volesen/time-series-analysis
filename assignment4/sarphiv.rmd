---
title: Assignment 4
author: sarphiv
output:
  bookdown::html_document2: default
  bookdown::pdf_document2: default
---
```{r include = FALSE}
# Disable inclusion of code chunks in the output
knitr::opts_chunk$set(echo = FALSE)
library("stats")
library("dplyr")

set.seed(1337)


# Function to reset the default parameters
par_defaults <- par(no.readonly = TRUE)
par_reset <- function() {
  par(par_defaults)
}
```

```{R}
# Load the data
data <- read.csv("A4_Kulhuse.csv", header = TRUE, sep = ",")
oxygen <- data$ODO
salinity <- data$Sal
time <- as.POSIXct(dplyr::pull(data, DateTime))
time_rel <- as.numeric(as.POSIXct(dplyr::pull(data, DateTime)))
time_rel <- (time_rel - time_rel[1])
time_delta <- mean(diff(time_rel), na.rm = T)
time_rel <- time_rel / time_delta

# Length
n <- length(time_rel)
```

#
```{R}
par(mfrow = c(2, 2))
plot(time, oxygen, type='l')
plot(time, salinity, type='l')
plot(oxygen, salinity)
boxplot(oxygen, salinity)
```

#
Example 10.6 may be relevant for further detail.

Assuming stationary dynamics. 
$$
X_t = X_{t-1} + \epsilon_t
$$

Must find variance of $\epsilon_t \sim \mathcal{N}(0, \sigma)$.

It is assumed that the salinity is measured directly, but with independent measurement noise.
$$
Y_t = X_t + \eta_t
$$

According to section 10.1, the matrices are given as
$$
A = I\\
B = 0\\
C = I
$$


#
```{R}
kalman <- function(A, C, X.var, Y.var, X0.pred, X0.pred.var, Y, n.ahead=1, B=NULL, u=NULL, outlier_sd=NULL, verbose=NULL) {
  # NOTE: Implementation is according to theorem 10.2
  #  Assuming stationary dynamics.

  # Initialize state and variance variables
  n <- length(Y) + n.ahead

  X.dim <- dim(X0.pred)[1]
  Y.dim <- dim(C)[1]

  X.recon     <- lapply(1:n, function(x) rep(NA, X.dim))
  X.recon.var <- lapply(1:n, function(x) matrix(NA, nrow = X.dim, ncol = X.dim))
  
  X.pred      <- lapply(1:n, function(x) rep(NA, X.dim))
  X.pred.var  <- lapply(1:n, function(x) matrix(NA, nrow = X.dim, ncol=X.dim))

  Y.pred.var  <- lapply(1:n, function(x) matrix(NA, nrow = Y.dim, ncol = Y.dim))


  # Initialize optional arguments
  if (is.null(u)) {
    u <- matrix(0, nrow = 1, ncol = n)
  }
  if (is.null(B)) {
    B <- matrix(0, nrow = X.dim, ncol = dim(u)[1])
  }


  # Helper functions
  recon.calc <- function(i) {
    # If missing observation, set reconstruction to prediction
    if (i > length(Y) || any(is.na(Y[[i]]))) {
      X.recon[[i]] <<- X.pred[[i]]
      X.recon.var[[i]] <<- X.pred.var[[i]]

      if ("missing" %in% verbose) {
        cat("Missing:", i, "\n")
      }

      return()
    }


    # Mahalanobis distance for outlier detection
    Y.error <- abs(Y[[i]] - C %*% X.pred[[i]])
    Y.error.sd <- sqrt((t(Y.error) %*% solve(Y.pred.var[[i]]) %*% Y.error) / Y.dim)

    # If outlier and outlier_sd is set, set reconstruction to prediction
    if (!is.null(outlier_sd) && (Y.error.sd > outlier_sd)) {
      X.recon[[i]] <<- X.pred[[i]]
      X.recon.var[[i]] <<- X.pred.var[[i]]

      if ("outlier" %in% verbose) {
        cat("Outlier:", i, "Sd:", Y.error.sd, "\n")
      }
    }
    # Else, reconstruct
    else {
      K <- X.pred.var[[i]] %*% t(C) %*% solve(Y.pred.var[[i]])

      X.recon[[i]] <<- X.pred[[i]] + K %*% (Y[[i]] - C %*% X.pred[[i]])
      X.recon.var[[i]] <<- X.pred.var[[i]] - K %*% C %*% X.pred.var[[i]]
    }

  }

  pred.calc <- function(i) {
    X.pred[[i]] <<- A %*% X.recon[[i-1]] + B %*% u[[i-1]]
    X.pred.var[[i]] <<- A %*% X.recon.var[[i-1]] %*% t(A) + X.var
    Y.pred.var[[i]] <<- C %*% X.pred.var[[i]] %*% t(C) + Y.var
  }


  # NOTE: Initial predictions set according to theorem 10.2.
  #  Not setting reconstruction directly as in lecture notes,
  #  as it would not incorporate dynamics and the first observation.
  X.pred[[1]] <- X0.pred
  X.pred.var[[1]] <- X0.pred.var

  Y.pred.var[[1]] <- C %*% X.pred.var[[1]] %*% t(C) + Y.var

  # Initial reconstruction
  recon.calc(1)


  # Kalman filter iterative implementation of recursion
  for (i in 2:n) {
    pred.calc(i)
    recon.calc(i)
  }


  # Return reconstructed and predicted values
  return(list(
    X.recon     = X.recon,
    X.recon.var = X.recon.var,
    X.pred      = X.pred,
    X.pred.var  = X.pred.var,
    Y.pred.var  = Y.pred.var
  ))
}


results.pure <- kalman(
  A=matrix(1, nrow = 1, ncol = 1),
  C=matrix(1, nrow = 1, ncol = 1),
  X.var=matrix(0.01, nrow = 1, ncol = 1),
  Y.var=matrix(0.005, nrow = 1, ncol = 1),
  X0.pred=matrix(salinity[1], nrow = 1, ncol = 1),
  X0.pred.var=matrix(var(salinity, na.rm = T), nrow = 1, ncol = 1),
  Y=lapply(salinity, function(x) x),
  verbose=c("missing")
)

```

```{R}
par_reset()
plot(time, salinity, type = "l")
lines(time, results.pure$X.pred[-(n+1)], col = "red")
```

```{R}
par_reset()
plot(time[800:950], salinity[800:950], type = "l")
lines(time[800:950], results.pure$X.pred[800:950], col = "red")
```

```{R}
par_reset()
plot(time[800:950], (salinity[800:950] - vapply(results.pure$X.pred[800:950], function(x) x[1, 1], c(1))) / sqrt(vapply(results.pure$X.pred.var[800:950], function(x) x[1, 1], c(1))), type = "p")
```

```{R}
print(results.pure$X.pred[[5000]])
print(results.pure$X.recon[[5000]])
print(results.pure$X.recon.var[[5000]])
print(results.pure$X.pred[[5000]])
print(results.pure$X.pred.var[[5000]])
print(results.pure$Y.pred.var[[5000]])
```

#
```{R}
results.skipped <- kalman(
  A=matrix(1, nrow = 1, ncol = 1),
  C=matrix(1, nrow = 1, ncol = 1),
  X.var=matrix(0.01, nrow = 1, ncol = 1),
  Y.var=matrix(0.005, nrow = 1, ncol = 1),
  X0.pred=matrix(salinity[1], nrow = 1, ncol = 1),
  X0.pred.var=matrix(var(salinity, na.rm = T), nrow = 1, ncol = 1),
  Y=lapply(salinity, function(x) x),
  outlier_sd=6,
  verbose=c("outlier")
)
```

```{R}
par_reset()
plot(time, salinity, type = "l")
lines(time, results.skipped$X.pred[-(n+1)], col = "red")
```

```{R}
par_reset()
plot(time[800:950], salinity[800:950], type = "l")
lines(time[800:950], results.skipped$X.pred[800:950], col = "red")
```

```{R}
par_reset()
plot(time[800:950], (salinity[800:950] - vapply(results.skipped$X.pred[800:950], function(x) x[1, 1], c(1))) / sqrt(vapply(results.skipped$X.pred.var[800:950], function(x) x[1, 1], c(1))), type = "p")
```

```{R}
print(results.skipped$X.pred[[5000]])
print(results.skipped$X.recon[[5000]])
print(results.skipped$X.recon.var[[5000]])
print(results.skipped$X.pred[[5000]])
print(results.skipped$X.pred.var[[5000]])
print(results.skipped$Y.pred.var[[5000]])
```

#

## Non-parametric bootstrap of observation rounding
```{R}
obs <- runif(1000000)
obs.round <- round(obs, 2)
obs.error <- abs(obs - obs.round)

par(mfrow = c(1, 2))
hist(obs, breaks = 100, freq=F)
hist(obs.error, breaks = 100, freq=F)
```

Seems like the error is uniformly distributed between 0 and 0.005. 
The lower bound is therefore 0.

```{R}
log.likelihood <- function(vars) {
  # WARN: Assuming no observations are missing
  A <- matrix(1, nrow = 1, ncol = 1)
  C <- matrix(1, nrow = 1, ncol = 1)
  Y.var <- matrix(vars[2], nrow = 1, ncol = 1)

  results <- kalman(
    A = A,
    C = C,
    X.var = matrix(vars[1], nrow = 1, ncol = 1),
    Y.var = Y.var,
    X0.pred = matrix(salinity[1], nrow = 1, ncol = 1),
    X0.pred.var = matrix(var(salinity, na.rm = T), nrow = 1, ncol = 1),
    Y = lapply(salinity[1:800], function(x) x)
  )

  R <- lapply(results$X.pred.var, function(x) C %*% x %*% t(C) + Y.var)
  error <- lapply(1:800, function(i) salinity[i] - C %*% A %*% results$X.pred[[i]])
  # NOTE: Swapped sign to maximize via optim, which minimizes
  return(sum(vapply(1:800, function(i) log(det(R[[i]])) + t(error[[i]]) %*% solve(R[[i]]) %*% error[[i]], c(1))))
}

print(nlminb(c(0.01, 0.005), log.likelihood, lower=c(1e-10, 0.000000), upper=c(0.5, 0.5)))
```

```{R}
log.likelihood <- Vectorize(function(X.var, Y.var) {
  # WARN: Assuming no observations are missing
  A <- matrix(1, nrow = 1, ncol = 1)
  C <- matrix(1, nrow = 1, ncol = 1)
  Y.var <- matrix(Y.var, nrow = 1, ncol = 1)

  results <- kalman(
    A = A,
    C = C,
    X.var = matrix(X.var, nrow = 1, ncol = 1),
    Y.var = Y.var,
    X0.pred = matrix(salinity[1], nrow = 1, ncol = 1),
    X0.pred.var = matrix(var(salinity, na.rm = T), nrow = 1, ncol = 1),
    Y = lapply(salinity[1:800], function(x) x)
  )

  R <- lapply(results$X.pred.var, function(x) C %*% x %*% t(C) + Y.var)
  error <- lapply(1:800, function(i) salinity[i] - C %*% A %*% results$X.pred[[i]])
  return(-sum(vapply(1:800, function(i) log(det(R[[i]])) + t(error[[i]]) %*% solve(R[[i]]) %*% error[[i]], c(1))))
})

par_reset()
X.vars <- seq(1e-3, 5e-3, by = 0.001)
Y.vars <- seq(0.000, 0.01, by=0.001)
persp(X.vars, Y.vars, outer(X.vars, Y.vars, log.likelihood), theta = 45, phi = 30, expand = 0.5, col = "lightblue")
```


```{R}
results.optimal <- kalman(
  A=matrix(1, nrow = 1, ncol = 1),
  C=matrix(1, nrow = 1, ncol = 1),
  X.var=matrix(0.001886608, nrow = 1, ncol = 1),
  Y.var=matrix(0.000, nrow = 1, ncol = 1),
  X0.pred=matrix(salinity[1], nrow = 1, ncol = 1),
  X0.pred.var=matrix(var(salinity, na.rm = T), nrow = 1, ncol = 1),
  Y=lapply(salinity, function(x) x),
  # outlier_sd = 6,
  # verbose = c("outlier")
)
```

```{R}
par_reset()
plot(time, salinity, type = "l")
lines(time, results.optimal$X.pred[-(n+1)], col = "red")
```

```{R}
par_reset()
plot(time[800:950], salinity[800:950], type = "l")
lines(time[800:950], results.optimal$X.pred[800:950], col = "red")
```

```{R}
par_reset()
plot(time[800:950], (salinity[800:950] - vapply(results.optimal$X.pred[800:950], function(x) x[1, 1], c(1))) / sqrt(vapply(results.optimal$X.pred.var[800:950], function(x) x[1, 1], c(1))), type = "p")
```

```{R}
print(results.optimal$X.pred[[5000]])
print(results.optimal$X.recon[[5000]])
print(results.optimal$X.recon.var[[5000]])
print(results.optimal$X.pred[[5000]])
print(results.optimal$X.pred.var[[5000]])
print(results.optimal$Y.pred.var[[5000]])
```


#
```{R}

```

